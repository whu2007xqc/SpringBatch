### 一、注册job
在lancher.run一个job之前，需要获取到这个job：  
`Job batchJob = jobRegistry.getJob(batchJobName);`  
Job是如何注册进去的？  
https://blog.csdn.net/shaoyangdd/article/details/100437349

### 二、执行job
可参考：  
https://blog.csdn.net/ray1205/article/details/79546099  
https://zhuanlan.zhihu.com/p/26327383

1. 通过JobLauncher运行job：`launcher.run(batchJob, batchJobParam)`  
batchJob为Job类型，batchJobParam为JobParameters类型  

2. 调用SimpleJobLauncher的run方法  
判断执行模式是start还是restart，如果是restart则需要校验是否可以重启  
校验jobParameters传入参数  
创建JobExecution  
调用Job类的`job.execute(jobExecution)`，此时通过new Runnable()异步执行

3. 调用AbstractJob的execute方法  
注册JobExecution，`JobSynchronizationManager.register(execution);`  
校验Job入参，`jobParametersValidator.validate(execution.getJobParameters());`  
设置Job状态，`execution.setStartTime(new Date());				updateStatus(execution, BatchStatus.STARTED);`  
调用`listener.beforeJob(execution);`
调用`doExecute(execution);`

4. 调用FlowJob或SimpleJob的doExecute方法  
以FlowJob为例，创建JobFlowExecutor并执行JobFlow: `flow.start(executor)`  
```java
	public FlowExecution start(FlowExecutor executor) throws FlowExecutionException {
		if (startState == null) {
			initializeTransitions();
		}
		State state = startState;
		String stateName = state.getName();
		return resume(stateName, executor);
	}
```

继续调用`state.handle(executor);`  
```java
while (isFlowContinued(state, status, stepExecution)) {
			stateName = state.getName();

			try {
				if (logger.isDebugEnabled()) {
					logger.debug("Handling state="+stateName);
				}
				status = state.handle(executor);
				stepExecution = executor.getStepExecution();
			}
			catch (FlowExecutionException e) {
				executor.close(new FlowExecution(stateName, status));
				throw e;
			}
			catch (Exception e) {
				executor.close(new FlowExecution(stateName, status));
				throw new FlowExecutionException(String.format("Ended flow=%s at state=%s with exception", name,
																	  stateName), e);
			}

			if (logger.isDebugEnabled()) {
				logger.debug("Completed state="+stateName+" with status="+status);
			}

			state = nextState(stateName, status, stepExecution);
		}
```

5. 调用StepState的handler方法，启动一个Step  
```java
	public FlowExecutionStatus handle(FlowExecutor executor) throws Exception {
		/*
		 * On starting a new step, possibly upgrade the last execution to make
		 * sure it is abandoned on restart if it failed.
		 */
		executor.abandonStepExecution();
		return new FlowExecutionStatus(executor.executeStep(step));
	}
```

6. 调用JobFlowExecutor的executeStep方法  
`StepExecution stepExecution = stepHandler.handleStep(step, execution);`  
