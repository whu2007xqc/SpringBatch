## 3. 主要语法/Domain Language of Batch
### Job
job的层次依次分为Job、JobInstance，JobExecution。

> 在Spring Batch中, Job是Step的简单容器. 它联结了多个Step，这些Step在逻辑上归属于一个Flow，并且可以为所有Step配置属性，比如是否可重跑。Job配置包括:
> * Job名称
> * Step实例的定义和执行顺序
> * Job是否可重跑

创建一个SimpleJob：
```java
@Bean
public Job footballJob() {
    return this.jobBuilderFactory.get("footballJob")
                     .start(playerLoad())
                     .next(gameLoad())
                     .next(playerSummarization())
                     .build();
}
```

#### JobParameter
> “一个JobInstance如何区别于另一个？”答案是：JobParameters。  
> JobParameters对象包含了一系列的参数用于启动Job。这些参数既可以用于区分JobInstance，又可以在执行Job期间使用。  
> 更为精确的定义： **JobInstance = Job + identifying JobParameters** .  

注意JobExecution参数：  
* Status： `BatchStatus`对象表示了运行的状态。运行中 = BatchStatus#STARTED。运行失败 = BatchStatus#FAILED。运行成功完成 = BatchStatus#COMPLETED

### Step
> Step拥有单独的StepExecution，需要与Job的JobExecution区分开。  
> 如果Step在正式运行之前就失败了，那么就没有Step运行记录被持久化到DB。StepExecution只会在Step真正开始运行后创建。  

#### StepExecution
参数列表参考：
https://docs.spring.io/spring-batch/docs/current/reference/html/index-single.html#stepexecution

### ExecutionContext
Job和Step都有对应的ExecutionContext，用于保存Job或Step的运行状态。最简单的应用场景就是重跑。  
> 一个JobExecution至少有一个ExecutionContext，一个StepExecution有且仅有一个ExecutionContext。  
> Step在每次commit点保存其上下文，而Job在两个Step运行期间保存上下文。

### JobRepository
用于持久化的工具。为JobLauncher，Job，Step提供了CRUD操作。
使用 Java 配置时，`@EnableBatchProcessing` 注释提供 JobRepository 作为开箱即用自动配置的组件之一。

### JobLauncher
> JobLauncher是一个简单的接口，用来根据JobParameters来启动Job。

## 4. 配置和运行Job/Configuring and Running a Job
### 配置Job/Configuring a Job
#### 重复运行/Restartability
禁止Job重复运行：  
```java
@Bean
public Job footballJob() {
    return this.jobBuilderFactory.get("footballJob")
                     .preventRestart()
                     ...
                     .build();
}
```

#### Listener
> afterJob方法无论是Job运行成功、失败还是停止都会被调用。如果要区分成功和失败，可以从JobExecution中获取状态：

```java
public void afterJob(JobExecution jobExecution){
    if (jobExecution.getStatus() == BatchStatus.COMPLETED ) {
        //job success
    }
    else if (jobExecution.getStatus() == BatchStatus.FAILED) {
        //job failure
    }
}
```
注意顺序：
1. 调用beforeJob -> 2. 调用execute执行job -> 3. 调用afterJob -> 4. JobRepository持久化到DB  
其中步骤2已经将运行状态更新到execution对象中了。  

#### 校验job参数/JobParametersValidator
在job运行之前校验参数，可继承`DefaultJobParametersValidator `接口实现自己的方法。
```java
@Bean
public Job job1() {
    return this.jobBuilderFactory.get("job1")
                     .validator(parametersValidator())
                     ...
                     .build();
}
```

### Java配置/Java Config
Java基础配置包含两部分：`@EnableBatchProcessing`注解与两个builder。  
`@EnableBatchProcessing`提供了搭建Job的基础配置。包括创建了StepScope实例，以及一系列的Bean：  
* JobRepository: bean name "jobRepository"
* JobLauncher: bean name "jobLauncher"
* JobRegistry: bean name "jobRegistry"
* PlatformTransactionManager: bean name "transactionManager"
* JobBuilderFactory: bean name "jobBuilders"
* StepBuilderFactory: bean name "stepBuilders"

*文档说通过配置`@EnableBatchProcessing`注解提供了基础配置，该基础配置是通过`BatchConfigurer`接口来完成的，其中注册了上述所有的Bean。*  
*这个过程是怎么完成的？DataSource是如何获取的？*  

### 配置一个JobRepository
如果要自己配置一个JobRepository，而不使用SpringBatch的默认配置。  
默认配置：  
```java
// This would reside in your BatchConfigurer implementation
@Override
protected JobRepository createJobRepository() throws Exception {
    JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean();
    factory.setDataSource(dataSource); //必须
    factory.setTransactionManager(transactionManager); //必须
    factory.setIsolationLevelForCreate("ISOLATION_SERIALIZABLE");  //设置事务隔离级别，非必须
    factory.setTablePrefix("BATCH_");  //表前缀，当有多个Spring batch程序公用一个库的时候，可能需要修改表名避免冲突。只能修改前缀，表名和字段名不能修改。
    factory.setMaxVarCharLength(1000);
    factory.setDatabaseType("db2");//数据库类型，只有在非标准数据库的情况下需要配置
    return factory.getObject();
}
```
如果没有配置DatabaseType，则会自动探测数据库类型。不同数据库的主键自增策略可能不同，因此需要重写`incrementerFactory`。  
如果以上配置都没有生效，就只能实现每个继承了`SimpleJobRepository`的Dao，以通常Spring的方式来连接数据库。


### 配置一个JobLauncher
如果要自己配置一个JobLauncher，而不使用SpringBatch的默认配置。  
最基本的实现就是`SimpleJobLauncher`，只需要配置JobRepository。  
```java
// This would reside in your BatchConfigurer implementation
@Override
protected JobLauncher createJobLauncher() throws Exception {
	SimpleJobLauncher jobLauncher = new SimpleJobLauncher();
	jobLauncher.setJobRepository(jobRepository);
	jobLauncher.afterPropertiesSet();
	return jobLauncher;
}
```
收到HTTP请求的时候，运行Job是异步的，以便`SimpleJobLauncher`能够立刻返回给调用者。

### Job操作
#### 运行Job/Running a Job
运行一个批量Job至少需要一个Job定义和一个JobLauncher，两者既可以在一个上下文中，也可以不在一个上下文。如果通过命令行来启动job，那么JVM会实例化每一个Job，每个Job都有它自己的JobLauncher。如果是通过HttpRequest来启动，那么一般只会有一个JobLauncher。

##### 通过命令行启动Job
继承`CommandLineJobRunner`接口  
> <bash$ java CommandLineJobRunner io.spring.EndOfDayJobConfiguration endOfDay schedule.date(date)=2007/05/05

${jobPath}：io.spring.EndOfDayJobConfiguration  
${jobName}：endOfDay   
${jobParameters}：schedule.date(date)=2007/05/05，格式key=value，可以多个。

##### 通过Web容器启动Job
使用Spring MVC的Controller，将job定义为Bean，并注册到框架之中。  
使用JobLauncher启动Job时，根据job名称（即Bean的名称）从`JobRegistry`获取相应的Bean来启动。

#### 停止Job/Stopping a Job
```java
Set<Long> executions = jobOperator.getRunningExecutions("sampleJob");
jobOperator.stop(executions.iterator().next());
```
Job不会立刻停止，特别是在运行业务代码的时候，框架无法控制。但只要控制权回到框架手中，就会将当前的`StepExecution`的状态设置为`atchStatus.STOPPED`，再同理处理`JobExecution`。

[Stop Job具体实践参考](https://github.com/whu2007xqc/SpringBatch/blob/main/Stop%20Job.md)
#### 废弃Job/Aborting a Job

### 操作Meta数据/Advanced Meta-Data Usage
[JobOperator、JobLauncher、JobRepository、JobExplorer的作用](https://docs.spring.io/spring-batch/docs/current/reference/html/index-single.html#advancedMetaData)  
JobExplorer用于查询Job元数据，是只读的。

#### JobRegistry
JobRegistry不是必需的，但对于跟踪当前有哪些Job是可用的会非常有用；对于从应用其他地方收集Job也很有用（Job定义在其他的地方）。JobRegistry提供了从Job名称到Job实例的映射，对于Http方式启动Job的情况下，可以通过Job名称获取Job并运行。    
JobRegistry在`@EnableBatchProcessing`中已经提供了，但也可以自定义JobRegistry。

有两种将Job填充到JobRegistry中的方法：
##### JobRegistryBeanPostProcessor
```java
@Autowired
private JobRegistry jobRegistry;

@Bean
public JobRegistryBeanPostProcessor jobRegistryBeanPostProcessor() {
    JobRegistryBeanPostProcessor postProcessor = new JobRegistryBeanPostProcessor();
    postProcessor.setJobRegistry(jobRegistry);
    return postProcessor;
}
```

##### AutomaticJobRegistrar
AutomaticJobRegistrar是一个基于Job生命周期的组件，它在创建Job上下文的时候注册Job。这样的一个好处是Job中的组件的名称不要求是全局唯一的，比如ItemReader的Bean名称在不同的Job中可以都叫Reader而不会起冲突。

```java
@Bean
public AutomaticJobRegistrar registrar() {

    AutomaticJobRegistrar registrar = new AutomaticJobRegistrar();
    registrar.setJobLoader(jobLoader());
    registrar.setApplicationContextFactories(applicationContextFactories());
    registrar.afterPropertiesSet();
    return registrar;
}
```
`JobLoader`负责管理子上下文的生命周期管理，并将Job注册到`JobRegistry`中。  
`ApplicationContextFactory`是负责创建子上下文（Job或Step的上下文），最常用的是`ClassPathXmlApplicationContextFactory`。它的一个特点是默认会将父上下文的配置复制到子上下文中。  

#### JobOperator
JobOperator`@EnableBatchProcessing`中已经注入了，但也可以自定义JobOperator。  
```java
 @Bean
 public SimpleJobOperator jobOperator(JobExplorer jobExplorer,
                                JobRepository jobRepository,
                                JobRegistry jobRegistry) {

	SimpleJobOperator jobOperator = new SimpleJobOperator();

	jobOperator.setJobExplorer(jobExplorer);
	jobOperator.setJobRepository(jobRepository);
	jobOperator.setJobRegistry(jobRegistry);
	jobOperator.setJobLauncher(jobLauncher);

	return jobOperator;
 }
```

#### JobParametersIncrementer
注意JobOperator提供的`startNextInstance`方法，它会创建一个Job的新实例从头运行Job。JobLauncher新起一个Job依靠不同的JobParameters，而`startNextInstance`使用`JobParametersIncrementer`来新建JobInstance。  
`JobParametersIncrementer`用于返回一个新的JobParameters对象，因此需要定义如何返回新的JobParameters，修改JobParameters中的某个或某几个属性来保证JobParameters在Job中唯一。  
参考官方提供的`RunIdIncrementer`类，其中使用了`JobParametersBuilder`来构造JobParameters对象。  

```java

```
