## 3. 主要语法/Domain Language of Batch
### Job
job的层次依次分为Job、JobInstance，JobExecution。

> 在Spring Batch中, Job是Step的简单容器. 它联结了多个Step，这些Step在逻辑上归属于一个Flow，并且可以为所有Step配置属性，比如是否可重跑。Job配置包括:
> * Job名称
> * Step实例的定义和执行顺序
> * Job是否可重跑

创建一个SimpleJob：
```java
@Bean
public Job footballJob() {
    return this.jobBuilderFactory.get("footballJob")
                     .start(playerLoad())
                     .next(gameLoad())
                     .next(playerSummarization())
                     .build();
}
```

#### JobParameter
> “一个JobInstance如何区别于另一个？”答案是：JobParameters。  
> JobParameters对象包含了一系列的参数用于启动Job。这些参数既可以用于区分JobInstance，又可以在执行Job期间使用。  
> 更为精确的定义： **JobInstance = Job + identifying JobParameters** .  

注意JobExecution参数：  
* Status： `BatchStatus`对象表示了运行的状态。运行中 = BatchStatus#STARTED。运行失败 = BatchStatus#FAILED。运行成功完成 = BatchStatus#COMPLETED

### Step
> Step拥有单独的StepExecution，需要与Job的JobExecution区分开。  
> 如果Step在正式运行之前就失败了，那么就没有Step运行记录被持久化到DB。StepExecution只会在Step真正开始运行后创建。  

#### StepExecution
参数列表参考：
https://docs.spring.io/spring-batch/docs/current/reference/html/index-single.html#stepexecution

### ExecutionContext
Job和Step都有对应的ExecutionContext，用于保存Job或Step的运行状态。最简单的应用场景就是重跑。  
> 一个JobExecution至少有一个ExecutionContext，一个StepExecution有且仅有一个ExecutionContext。  
> Step在每次commit点保存其上下文，而Job在两个Step运行期间保存上下文。

### JobRepository
用于持久化的工具。为JobLauncher，Job，Step提供了CRUD操作。
使用 Java 配置时，`@EnableBatchProcessing` 注释提供 JobRepository 作为开箱即用自动配置的组件之一。

### JobLauncher
> JobLauncher是一个简单的接口，用来根据JobParameters来启动Job。

## 4. 配置和运行Job/Configuring and Running a Job
### 配置Job/Configuring a Job
#### 重复运行/Restartability
禁止Job重复运行：  
```java
@Bean
public Job footballJob() {
    return this.jobBuilderFactory.get("footballJob")
                     .preventRestart()
                     ...
                     .build();
}
```

#### Listener
> afterJob方法无论是Job运行成功还是失败都会被调用。如果要区分成功和失败，可以从JobExecution中获取状态：

```java
public void afterJob(JobExecution jobExecution){
    if (jobExecution.getStatus() == BatchStatus.COMPLETED ) {
        //job success
    }
    else if (jobExecution.getStatus() == BatchStatus.FAILED) {
        //job failure
    }
}
```
注意顺序：
1. 调用beforeJob -> 2. 调用execute执行job -> 3. 调用afterJob -> 4. JobRepository持久化到DB  
其中步骤2已经将运行状态更新到execution对象中了。  

#### 校验job参数/JobParametersValidator
在job运行之前校验参数，可继承`DefaultJobParametersValidator `接口实现自己的方法。
```java
@Bean
public Job job1() {
    return this.jobBuilderFactory.get("job1")
                     .validator(parametersValidator())
                     ...
                     .build();
}
```

### Java配置/Java Config
Java基础配置包含两部分：`@EnableBatchProcessing`注解与两个builder。  
`@EnableBatchProcessing`提供了搭建Job的基础配置。包括创建了StepScope实例，以及一系列的Bean：  
* JobRepository: bean name "jobRepository"
* JobLauncher: bean name "jobLauncher"
* JobRegistry: bean name "jobRegistry"
* PlatformTransactionManager: bean name "transactionManager"
* JobBuilderFactory: bean name "jobBuilders"
* StepBuilderFactory: bean name "stepBuilders"

*文档说通过配置`@EnableBatchProcessing`注解提供了基础配置，该基础配置是通过`BatchConfigurer`接口来完成的，其中注册了上述所有的Bean。*  
*这个过程是怎么完成的？DataSource是如何获取的？*  

### 配置一个JobRepository
如果要自己配置一个JobRepository，而不使用SpringBatch的默认配置。  
默认配置：  
```java
// This would reside in your BatchConfigurer implementation
@Override
protected JobRepository createJobRepository() throws Exception {
    JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean();
    factory.setDataSource(dataSource); //必须
    factory.setTransactionManager(transactionManager); //必须
    factory.setIsolationLevelForCreate("ISOLATION_SERIALIZABLE");  //设置事务隔离级别，非必须
    factory.setTablePrefix("BATCH_");  //表前缀，当有多个Spring batch程序公用一个库的时候，可能需要修改表名避免冲突。只能修改前缀，表名和字段名不能修改。
    factory.setMaxVarCharLength(1000);
    factory.setDatabaseType("db2");//数据库类型，只有在非标准数据库的情况下需要配置
    return factory.getObject();
}
```
如果没有配置DatabaseType，则会自动探测数据库类型。不同数据库的主键自增策略可能不同，因此需要重写`incrementerFactory`。  
如果以上配置都没有生效，就只能实现每个继承了`SimpleJobRepository`的Dao，以通常Spring的方式来连接数据库。


### 配置一个JobLauncher
如果要自己配置一个JobLauncher，而不使用SpringBatch的默认配置。  
最基本的实现就是`SimpleJobLauncher`，只需要配置JobRepository。  
```java
// This would reside in your BatchConfigurer implementation
@Override
protected JobLauncher createJobLauncher() throws Exception {
	SimpleJobLauncher jobLauncher = new SimpleJobLauncher();
	jobLauncher.setJobRepository(jobRepository);
	jobLauncher.afterPropertiesSet();
	return jobLauncher;
}
```
收到HTTP请求的时候，运行Job是异步的，以便`SimpleJobLauncher`能够立刻返回给调用者。

### Job操作
#### 运行Job/Running a Job

#### 停止Job/Stopping a Job
```java
Set<Long> executions = jobOperator.getRunningExecutions("sampleJob");
jobOperator.stop(executions.iterator().next());
```
Job不会立刻停止，特别是在运行业务代码的时候，框架无法控制。但只要控制权回到框架手中，就会将当前的`StepExecution`的状态设置为`atchStatus.STOPPED`，再处理`JobExecution`。

#### 废弃Job/Aborting a Job
